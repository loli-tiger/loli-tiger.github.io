<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>实时Markdown流式渲染</title>
    <script src="https://thunkable.github.io/webviewer-extension/thunkableWebviewerExtension.js"></script>
    <style>
        /* 精简样式 */
        #content {
            background: rgb(200, 194, 171);
            min-height: 100vh;
            padding: 20px;
            white-space: pre-wrap; /* 保留换行 */
        }
        #content::after {
            content: "|";
            animation: blink 1s step-end infinite;
            color: #333;
        }
        @keyframes blink { 50% { opacity: 0 } }
    </style>
</head>
<body>
    <div id="content"></div>

    <script>
        // ================= 实时流式处理核心逻辑 =================
        let buffer = '';
        let currentParent = document.getElementById('content');
        const nodeStack = [currentParent];
        let isProcessing = false;

        // 轻量级Markdown解析器（按字符处理）
        const mdRules = {
            '#': 'h1', '##': 'h2', '###': 'h3',
            '*': 'li', '-': 'li', '>': 'blockquote',
            '`': 'code'
        };

        // 动态创建元素
        function createElement(tag) {
            const el = document.createElement(tag);
            currentParent.appendChild(el);
            return el;
        }

        // 实时处理每个字符
        async function processChar(char) {
            buffer += char;
            
            // 即时解析特殊符号
            if (['\n', '#', '*', '-', '>', '`'].includes(char)) {
                flushBuffer();
            }

            // 立即更新显示
            if (currentParent.lastChild?.nodeType === Node.TEXT_NODE) {
                currentParent.lastChild.textContent += char;
            } else {
                currentParent.appendChild(document.createTextNode(char));
            }
            
            await new Promise(r => requestAnimationFrame(r));
        }

        // 处理缓冲区
        function flushBuffer() {
            const match = Object.keys(mdRules).find(k => buffer.startsWith(k));
            if (!match) return;

            const tag = mdRules[match];
            const newElement = createElement(tag);
            newElement.textContent = buffer.slice(match.length);
            
            if (['h1','h2','h3','li','blockquote'].includes(tag)) {
                nodeStack.push(newElement);
                currentParent = newElement;
            }
            
            buffer = '';
        }

        // 接收消息入口（逐字处理）
        ThunkableWebviewerExtension.receiveMessage(async (chunk) => {
            for (const char of chunk) {
                await processChar(char);
                await new Promise(r => setTimeout(r, 0)); // 让出事件循环
            }
        });
    </script>
</body>
</html>
